"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("../../core/errors/types");
var Transformation;
(function (Transformation) {
    function compile(arg1, ...args) {
        let steps;
        if (!arg1) {
            steps = [];
        }
        else if (Array.isArray(arg1)) {
            steps = arg1;
        }
        else {
            steps = [arg1, ...args];
        }
        if (steps.length === 0)
            throw new types_1.WampusInvalidArgument("Cannot compile a list with zero transforms", {});
        let firstSkip;
        let curSkip;
        for (let i = 0; i < steps.length; i++) {
            let z = i;
            let lastNext = curSkip;
            curSkip = function (value) {
                let step = steps[z];
                this.next = lastNext;
                return step(value, this);
            };
        }
        firstSkip = curSkip;
        let createTransformCtx = (set) => {
            return {
                recurse(obj) {
                    if (set.has(obj)) {
                        throw new types_1.WampusInvalidArgument("Transformation has tried to do circular recursion.", {
                            obj
                        });
                    }
                    set.add(obj);
                    try {
                        let ctx = createTransformCtx(set);
                        let res = ctx.next(obj);
                        return res;
                    }
                    finally {
                        set.delete(obj);
                    }
                },
                next(x) {
                    return firstSkip.call(this, x);
                }
            };
        };
        return (x) => {
            let ctx = createTransformCtx(new Set());
            return ctx.next(x);
        };
    }
    Transformation.compile = compile;
})(Transformation = exports.Transformation || (exports.Transformation = {}));
class StepByStepTransformer {
    constructor() {
        this._transforms = [];
        this._compiled = null;
    }
    add(...ts) {
        for (let t of ts) {
            this._transforms.push(t);
        }
        this._compiled = Transformation.compile(this._transforms);
    }
    get transform() {
        return this._compiled;
    }
}
exports.StepByStepTransformer = StepByStepTransformer;
//# sourceMappingURL=recursive-transform.js.map