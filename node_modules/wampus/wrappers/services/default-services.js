"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const services_1 = require("../services");
const uris_1 = require("../../core/protocol/uris");
const _ = require("lodash");
const types_1 = require("../../core/errors/types");
exports.createDefaultServices = () => {
    let s = {
        transforms: new services_1.TransformSet(),
        stackTraceService: {
            format(err, cs) {
                let formatter = Error.prepareStackTrace;
                if (!formatter) {
                    return cs.map(x => `   at ${x.getFunctionName()} (${x.getFileName()}:${x.getLineNumber()}:${x.getColumnNumber()}`).join("\n");
                }
                else {
                    return formatter.call(Error, err, cs);
                }
            },
            capture(ctor) {
                if ("stackTraceLimit" in Error) {
                    const origTrace = Error.prepareStackTrace;
                    Error.prepareStackTrace = (err, stack) => ({ err, stack });
                    let obj = { stack: null };
                    Error.captureStackTrace(obj, ctor);
                    let { stack, err } = obj.stack;
                    Error.prepareStackTrace = origTrace;
                    return stack;
                }
                return null;
            },
            enabled: true
        }
    };
    let x = s.transforms;
    x.jsonToObject.add((x, ctrl) => {
        if (!x || typeof x !== "object")
            return x;
        if (Array.isArray(x)) {
            return x.map(x => ctrl.recurse(x));
        }
        let res = _.mapValues(x, v => ctrl.recurse(v));
        return res;
    });
    x.objectToJson.add((x, ctrl) => {
        if (!x || typeof x !== "object")
            return x;
        if (Array.isArray(x)) {
            return x.map(x => ctrl.recurse(x));
        }
        let res = _.mapValues(x, v => ctrl.recurse(v));
        return res;
    });
    x.errorToErrorResponse.add((err, ctrl) => {
        if (err instanceof types_1.WampusInvocationCanceledError) {
            return {
                error: uris_1.WampUri.Error.Canceled,
                details: {
                    message: "Invocation cancelled"
                }
            };
        }
        return {
            args: [],
            error: uris_1.WampUri.Error.RuntimeError,
            details: {
                message: err.message
            },
            kwargs: _.pick(err, ["message", "name", "stack", ...Object.keys(err)])
        };
    });
    x.errorResponseToError.add((err, ctrl) => {
        return err;
    });
    return s;
};
//# sourceMappingURL=default-services.js.map