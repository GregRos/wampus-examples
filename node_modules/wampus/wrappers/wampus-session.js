"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const registration_ticket_1 = require("./tickets/registration-ticket");
const call_1 = require("./tickets/call");
const subscription_1 = require("./tickets/subscription");
const _ = require("lodash");
const ticket_1 = require("./tickets/ticket");
const default_services_1 = require("./services/default-services");
class WampusSession extends ticket_1.Ticket {
    constructor(_core, initServices) {
        super();
        this._core = _core;
        let services = default_services_1.createDefaultServices();
        initServices && initServices(services);
        this._services = services;
    }
    /**
     * Gets the realm this session belongs to.
     */
    get realm() {
        return this._core.realm;
    }
    /**
     * Gets whether this session is still alive.
     */
    get isActive() {
        return this._core.isActive;
    }
    /**
     * Gets information about this session.
     */
    get details() {
        return this._core.details;
    }
    /**
     * Gets this session's ID.
     */
    get sessionId() {
        return this._core.sessionId;
    }
    /**
     * Exposes the WAMP protocol client used to send and receive protocol messages. This gives you lower-level control over the session.
     * Don't use it unless you know what you're doing.
     */
    get protocol() {
        return this._core.protocol;
    }
    /**
     * Closes this session.
     */
    close() {
        return this._core.close();
    }
    /**
     * Calls a procedure via the WAMP protocol
     * @param wArgs All the information required to make the call.
     * @returns An awaitable call ticket that lets you receive progress from the call.
     */
    call(wArgs) {
        wArgs = Object.assign({}, wArgs, { kwargs: this._services.transforms.objectToJson.transform(wArgs.kwargs), args: wArgs.args ? wArgs.args.map(this._services.transforms.objectToJson.transform) : wArgs.args });
        return call_1.CallTicket.create(this._core.call(wArgs), this._services);
    }
    ;
    /**
     * Registers a procedure via the WAMP protocol.
     * @param wArgs All the information needed to register the procedure, including the backing callback.
     * @returns A promise that resolves to a registration ticket once the procedure has been registered.
     */
    register(wArgs) {
        return __awaiter(this, void 0, void 0, function* () {
            let coreRegTicket = this._core.register(wArgs);
            let ticket = yield registration_ticket_1.RegistrationTicket.create(coreRegTicket, this._services);
            ticket._handle(wArgs.called);
            return ticket;
        });
    }
    ;
    /**
     * Registers multiple procedures based on an object specification.
     * @param procedures A procedure specification.
     * @see WampusProcedureDefinitions
     */
    registerAll(procedures) {
        return __awaiter(this, void 0, void 0, function* () {
            let tickets = [];
            _.forIn(procedures, (v, k) => {
                let obj = {
                    name: k,
                    options: {},
                    called: null
                };
                if (_.isFunction(v)) {
                    obj.called = v;
                }
                else {
                    obj.options = v.options || {};
                    obj.called = v.called;
                }
                tickets.push(this.register(obj));
            });
            let resolvedTickets = yield Promise.all(tickets);
            return ticket_1.Ticket.combine(resolvedTickets);
        });
    }
    /**
     * Subscribes to a topic via the WAMP protocol.
     * @param wArgs All the information needed to create the subscription.
     * @returns A promise that resolves to a subscription ticket that can be used to receive events.
     */
    topic(wArgs) {
        return subscription_1.SubscriptionTicket.create(this._core.topic(wArgs), this._services);
    }
    /**
     * Publishes an event via the WAMP protocol.
     * @param wArgs All the information needed to publish the event.
     * @returns A promise that resolves once the event has been published.
     */
    publish(wArgs) {
        wArgs = Object.assign({}, wArgs, { kwargs: this._services.transforms.objectToJson.transform(wArgs.kwargs), args: wArgs.args ? wArgs.args.map(this._services.transforms.objectToJson.transform) : wArgs.args });
        return this._core.publish(wArgs);
    }
    ;
}
exports.WampusSession = WampusSession;
//# sourceMappingURL=wampus-session.js.map