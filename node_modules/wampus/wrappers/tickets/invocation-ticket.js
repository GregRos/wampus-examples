"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const _ = require("lodash");
const object_1 = require("../../utils/object");
const types_1 = require("../../core/errors/types");
/**
 * A ticket for the invocation of a procedure, on the callee's side.
 */
class InvocationTicket {
    /**
     * @internal
     * @param _base
     * @param _services
     * @param _source
     */
    constructor(_base, _services, _source) {
        this._base = _base;
        this._services = _services;
        this._source = _source;
        this.args = _base.args ? _base.args.map(_services.transforms.jsonToObject.transform) : _base.args;
        this.kwargs = _services.transforms.jsonToObject.transform(_base.kwargs);
        this.options = _base.options;
        this.name = _base.name;
        this.invocationId = _base.invocationId;
        object_1.ObjectHelpers.makeEverythingNonEnumerableExcept(this, "args", "kwargs", "options", "name", "invocationId");
    }
    /**
     * Whether this invocation has already received the final result.
     */
    get isHandled() {
        return this._base.isHandled;
    }
    /**
     * The source {{RegistrationTicket}} for the procedure that created this invocation ticket.
     */
    get source() {
        return this._source;
    }
    _applyOutputTransforms(obj) {
        let clone = _.clone(obj);
        clone.args = clone.args ? clone.args.map(this._services.transforms.objectToJson.transform) : clone.args;
        clone.kwargs = this._services.transforms.objectToJson.transform(clone.kwargs);
        return clone;
    }
    _error(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            msg = this._applyOutputTransforms(msg);
            yield this._base.error(msg);
        });
    }
    /**
     * Checks if this call has been cancelled, and continues to wait for {{time}} milliseconds for a cancellation request.
     * @param time The time to wait for. Can be 0.
     * @returns A promise that resolves to a {{CancellationTicket}} if one is found, or no value otherwise.
     */
    waitForCancel(time) {
        return this._base.cancellation.pipe(operators_1.takeUntil(rxjs_1.timer(time)), operators_1.map(token => {
            return Object.assign({}, token, { throw() {
                    throw new types_1.WampusInvocationCanceledError("Invocation has been cancelled", {});
                } });
        })).toPromise();
    }
    /**
     * @internal
     * @param handler
     * @private
     */
    _handle(handler) {
        let ticket = this;
        let handleError = (err) => __awaiter(this, void 0, void 0, function* () {
            if (this._services.stackTraceService.enabled) {
                err.stack = err.stack + "\n(Wampus Registered At)" + this._services.stackTraceService.format("", this.source.trace.created);
            }
            let errResponse = ticket._services.transforms.errorToErrorResponse.transform(err);
            if (!this.isHandled) {
                yield ticket._error(errResponse);
            }
            else {
                throw err;
            }
        });
        try {
            let result = handler(this);
            if (result instanceof Promise) {
                result.then((ret) => __awaiter(this, void 0, void 0, function* () {
                    return ticket._return(ret);
                }), err => {
                    return handleError(err);
                });
            }
        }
        catch (err) {
            handleError(err);
        }
    }
    /**
     * Sends a progress report to the caller.
     * The message sent by this method will have its `options.progress` field set to true.
     * @param msg The contents of the progress message.
     */
    progress(msg) {
        return __awaiter(this, void 0, void 0, function* () {
            msg = this._applyOutputTransforms(msg);
            yield this._base.progress(msg);
        });
    }
    _return(args) {
        return __awaiter(this, void 0, void 0, function* () {
            args = this._applyOutputTransforms(args);
            yield this._base.return(args);
        });
    }
}
exports.InvocationTicket = InvocationTicket;
object_1.ObjectHelpers.makeEverythingNonEnumerableExcept(InvocationTicket.prototype);
//# sourceMappingURL=invocation-ticket.js.map