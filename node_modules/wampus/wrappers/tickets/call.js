"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const rxjs_other_1 = require("../../utils/rxjs-other");
const operators_1 = require("rxjs/operators");
const rxjs_operators_1 = require("../../utils/rxjs-operators");
const ticket_1 = require("./ticket");
const object_1 = require("../../utils/object");
const types_1 = require("../../core/errors/types");
const call_result_1 = require("./call-result");
/**
 * An in-progress RPC call via the WAMP protocol.
 */
class CallTicket extends ticket_1.Ticket {
    /**
     * Should not be called from user code.
     * @param never
     */
    constructor(never) {
        super();
        this._base = undefined;
        this._services = undefined;
        this._adapter = undefined;
        this.trace = {
            created: null
        };
    }
    /**
     * Creates a new feature-wrapped call ticket using a base ticket and a set of services.
     * Should not normally be called from user code.
     * @param call The base ticket provided by the WampusCoreSession object.
     * @param services
     */
    static create(call, services) {
        let ticket = new CallTicket(null);
        ticket.trace.created = services.stackTraceService.capture(CallTicket.create);
        ticket._base = call;
        ticket._services = services;
        ticket._replayProgress = call.progress.pipe(operators_1.map(prog => {
            let newResult = new call_result_1.CallResultData({
                details: prog.details,
                args: prog.args ? prog.args.map(services.transforms.jsonToObject.transform) : prog.args,
                kwargs: services.transforms.jsonToObject.transform(prog.kwargs),
                isProgress: prog.isProgress,
                source: ticket
            }, ticket);
            return newResult;
        }), operators_1.catchError(err => {
            if (err instanceof types_1.WampusInvocationError) {
                err.args = err.args ? err.args.map(services.transforms.jsonToObject.transform) : err.args;
                err.kwargs = services.transforms.jsonToObject.transform(err.kwargs);
                err = services.transforms.errorResponseToError.transform(err);
            }
            if (ticket.trace.created)
                err.stack = services.stackTraceService.format(err, ticket.trace.created);
            throw err;
        })).pipe(rxjs_operators_1.publishReplayAutoConnect());
        ticket._adapter = new rxjs_other_1.RxjsEventAdapter(ticket.progress, x => {
            return {
                name: "data",
                arg: x
            };
        }, ["data"]);
        object_1.ObjectHelpers.makeEverythingNonEnumerableExcept(ticket, "info");
        return ticket;
    }
    /**
     * Provides info about this RPC call.
     */
    get info() {
        return this._base.info;
    }
    /**
     * Whether this call has been finished.
     */
    get isOpen() {
        return this._base.isOpen;
    }
    /**
     * An observable that fires whenever a message is received from the callee.
     * Sends progress, error, and result messages.
     */
    get progress() {
        return this._replayProgress;
    }
    /**
     * Returns a promise that resolves with the final result of the call.
     */
    get result() {
        return this.progress.toPromise();
    }
    /**
     * Cancels the call, or if the call is already finished, does nothing.
     * @param cancelMode The type of the cancellation, as written in the WAMP specification.
     */
    close(cancelMode) {
        return this._base.close(cancelMode);
    }
    /**
     * Removes a handler.
     * @param name The name of the event.
     * @param handler The handler function.
     */
    off(name, handler) {
        this._adapter.off(name, handler);
    }
    /**
     * Adds a handler.
     * @param name The name of the event.
     * @param handler The handler.
     */
    on(name, handler) {
        this._adapter.on(name, handler);
    }
    /**
     * Added so that this call ticket can be awaited or used as a promise.
     * @see Promise.then
     * @param onfulfilled
     * @param onrejected
     */
    then(onfulfilled, onrejected) {
        return this.result.then(onfulfilled, onrejected);
    }
    /**
     * Added so this call ticket can be awaited or used as a promise.
     * @see Promise.catch
     * @param onrejected
     */
    catch(onrejected) {
        return this.result.catch(onrejected);
    }
}
exports.CallTicket = CallTicket;
object_1.ObjectHelpers.makeEverythingNonEnumerableExcept(CallTicket.prototype, "info");
//# sourceMappingURL=call.js.map