"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const operators_1 = require("rxjs/operators");
const rxjs_other_1 = require("../../utils/rxjs-other");
const ticket_1 = require("./ticket");
const object_1 = require("../../utils/object");
/**
 * A ticket for a topic subscription.
 */
class SubscriptionTicket extends ticket_1.Ticket {
    constructor(never) {
        super();
        this.trace = {
            created: null
        };
    }
    /**
     * A hot observable that emits all the events received by this subscription in real time.
     */
    get events() {
        return this._base.events.pipe(operators_1.map(x => {
            let data = {
                args: x.args ? x.args.map(x => this._services.transforms.jsonToObject.transform(x)) : x.args,
                kwargs: this._services.transforms.jsonToObject.transform(x.kwargs),
                details: x.details,
                source: this
            };
            object_1.ObjectHelpers.makeEverythingNonEnumerableExcept(data, "args", "kwargs", "details");
            return data;
        }));
    }
    ;
    /**
     * @internal
     * @param subscribing
     * @param services
     */
    static create(subscribing, services) {
        return __awaiter(this, void 0, void 0, function* () {
            let trace = services.stackTraceService.capture(SubscriptionTicket.create);
            let coreTicket = yield subscribing.catch(err => {
                if (trace)
                    err.stack = services.stackTraceService.format(err, trace);
                throw err;
            });
            let ticket = new SubscriptionTicket(null);
            ticket.trace.created = trace;
            ticket._base = coreTicket;
            ticket._services = services;
            ticket._adapter = new rxjs_other_1.RxjsEventAdapter(ticket.events, x => {
                return {
                    name: "event",
                    arg: x
                };
            }, ["event"]);
            object_1.ObjectHelpers.makeEverythingNonEnumerableExcept(ticket);
            return ticket;
        });
    }
    /**
     * Info about this subscription.
     */
    get info() {
        return this._base.info;
    }
    /**
     * Whether this subscription is still active.
     */
    get isOpen() {
        return this._base.isOpen;
    }
    /**
     * Closes this subscription.
     */
    close() {
        return this._base.close();
    }
    /**
     * Removes an event handler from this ticket.
     * @param name The name of the event.
     * @param handler The handler
     */
    off(name, handler) {
        this._adapter.off(name, handler);
    }
    /**
     * Adds an event handler to this ticket.
     * @param name The name of the event.
     * @param handler The handler
     */
    on(name, handler) {
        this._adapter.on(name, handler);
    }
}
exports.SubscriptionTicket = SubscriptionTicket;
object_1.ObjectHelpers.makeEverythingNonEnumerableExcept(SubscriptionTicket.prototype, "info");
//# sourceMappingURL=subscription.js.map