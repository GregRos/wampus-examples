"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("../errors/types");
const WebSocket = require('isomorphic-ws');
const ext_promise_1 = require("../../utils/ext-promise");
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const rxjs_operators_1 = require("../../utils/rxjs-operators");
const _ = require("lodash");
class WebsocketTransport {
    get name() {
        return `websocket.${this._config.serializer.id}`;
    }
    /**
     * Use `WebsocketTransport.create` instead.
     * @param {never} never
     */
    constructor(never) {
    }
    /**
     * Creates a COLD stream that will create a [[WebsocketTransport]] when subscribed to.
     * The [[WebsocketTransport]] will be automatically closed when the subscription ends.
     * @param {WebsocketTransportConfig} config
     * @returns {Observable<WebsocketTransport>}
     */
    static create(config) {
        return __awaiter(this, void 0, void 0, function* () {
            if (config.timeout != null && typeof config.timeout !== "number") {
                throw new types_1.WampusInvalidArgument("Timeout value {timeout} is invalid.", {
                    timeout: config.timeout
                });
            }
            if (!config.serializer || typeof config.serializer !== "object" || !["serialize", "deserialize", "id"].every(x => x in config.serializer)) {
                throw new types_1.WampusInvalidArgument("Serializer is not valid.", {
                    obj: config.serializer
                });
            }
            let errorOnTimeOut$ = config.timeout == null ? rxjs_1.NEVER : rxjs_1.of(null).pipe(operators_1.delay(config.timeout), operators_1.map(() => {
                throw new types_1.WampusNetworkError("WebSocket connection timed out.", {
                    url: config.url
                });
            }));
            let transport$ = rxjs_1.Observable.create(sub => {
                let transport = new WebsocketTransport(null);
                transport._config = config;
                try {
                    var ws = new WebSocket(config.url, config.forceProtocol || `wamp.2.${config.serializer.id}`, {});
                }
                catch (err) {
                    throw (new types_1.WampusNetworkError(`The WebSocket client could not be created. ${err.message}`, {
                        innerError: err
                    }));
                }
                transport._ws = ws;
                let closeEvent$ = rxjs_1.fromEvent(ws, "close").pipe(operators_1.map(x => {
                    return {
                        type: "closed",
                        data: x
                    };
                }));
                let msgEvent$ = rxjs_1.fromEvent(ws, "message").pipe(operators_1.map((msg) => {
                    try {
                        var result = transport._config.serializer.deserialize(msg.data);
                    }
                    catch (err) {
                        return {
                            type: "error",
                            data: new types_1.WampusNetworkError("Received a message that could not be deserialized.", {
                                innerError: err
                            })
                        };
                    }
                    return {
                        type: "message",
                        data: result
                    };
                }));
                let errorEvent$ = rxjs_1.fromEvent(ws, "error").pipe(operators_1.map(x => {
                    return {
                        type: "error",
                        data: new types_1.WampusNetworkError("The WebSocket client emitted an error.", {
                            innerError: x
                        })
                    };
                }));
                let messages = rxjs_1.merge(closeEvent$, errorEvent$, msgEvent$).pipe(rxjs_operators_1.skipAfter((x) => {
                    return x.type === "closed";
                }));
                transport.events$ = messages;
                if (ws.readyState === ws.OPEN) {
                    sub.next(transport);
                }
                ws.onopen = () => {
                    ws.onopen = null;
                    sub.next(transport);
                };
                ws.onerror = event => {
                    ws.onerror = ws.onopen = null;
                    let err = new types_1.WampusNetworkError(`Failed to establish WebSocket connection with ${config.url}. ${event.message}`, {
                        innerError: event.error
                    });
                    sub.error(err);
                };
            });
            return rxjs_1.race(errorOnTimeOut$, transport$).pipe(operators_1.take(1)).toPromise();
        });
    }
    get isActive() {
        return !this._expectingClose && !_.includes([WebSocket.CLOSED, WebSocket.CLOSING], this._ws.readyState);
    }
    close(x) {
        let { code, data } = x || { code: undefined, data: undefined };
        if (this._expectingClose) {
            return this._expectingClose;
        }
        this._expectingClose = new ext_promise_1.MyPromise((resolve, reject) => {
            if (this._ws.readyState === this._ws.CLOSED)
                resolve();
            this._ws.once("close", (msg) => {
                resolve();
            });
            if (this._ws.readyState !== this._ws.CLOSING) {
                this._ws.close(code, data);
            }
        });
        return this._expectingClose;
    }
    send$(msg) {
        if (this._expectingClose) {
            return rxjs_1.throwError(new types_1.WampusNetworkError("This transport is closing or has already closed."));
        }
        return rxjs_1.Observable.create(sub => {
            try {
                var payload = this._config.serializer.serialize(msg);
            }
            catch (err) {
                throw new types_1.WampusNetworkError("The message could not be serialized.", {
                    err
                });
            }
            this._ws.send(payload, {}, err => {
                if (err) {
                    sub.error(new types_1.WampusNetworkError("Failed to send message via the web socket transport.", {
                        innerError: err
                    }));
                }
                else {
                    sub.complete();
                }
            });
            return {
                unsubscribe() {
                }
            };
        });
    }
}
exports.WebsocketTransport = WebsocketTransport;
//# sourceMappingURL=websocket.js.map