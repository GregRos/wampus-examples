"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const types_1 = require("../errors/types");
const prefix_router_1 = require("./prefix-router");
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const ext_promise_1 = require("../../utils/ext-promise");
/**
 * A message-based WAMP protocol client that allows sending WAMP messages and receiving them.
 */
class WampProtocolClient {
    /**
     * Use [[WampProtocolClient.create]].
     * @param {never} never
     */
    constructor(never) {
        this._onClosed = new rxjs_1.Subject();
        this._onUnknownMessage = new rxjs_1.Subject();
        this._defaultRoute = {
            key: [],
            error(err) {
                console.error(err);
            },
            next: (x) => {
                this._onUnknownMessage.next(x);
            }
        };
    }
    /**
     * Creates an instance of the [[WampProtocolClient]].
     * @param transport The transport used to send and receive messages.
     * @param selector Used to transform messages from a raw array format to an object format.
     * @returns WampProtocolClient<T>
     */
    static create(transport, selector) {
        let messenger = new WampProtocolClient(null);
        messenger.transport = transport;
        messenger._parser = selector;
        let router = messenger._router = new prefix_router_1.PrefixRouter();
        messenger._setupRouter();
        return messenger;
    }
    /**
     * An observable that notifies when the underlying transport is closed.
     */
    get onClosed() {
        return this._onClosed.asObservable();
    }
    _setupRouter() {
        this.transport.events$.subscribe({
            next: x => {
                if (x.type === "error") {
                    let all = this._router.matchAll();
                    if (all.length === 0) {
                        this._defaultRoute.error(x.data);
                    }
                    else {
                        all.forEach(route => route.error(x.data));
                    }
                }
                else if (x.type === "message") {
                    if (!(Array.isArray(x.data))) {
                        throw new types_1.WampusNetworkError("Non-array message.", {});
                    }
                    let msg = this._parser(x.data);
                    let routes = this._router.match(x.data);
                    routes.forEach(route => route.next(msg));
                    if (routes.length === 0) {
                        this._defaultRoute.next(msg);
                    }
                }
                else if (x.type === "closed") {
                    this._onClosed.next(x.data);
                    this._onClosed.complete();
                }
            },
            complete: () => {
            },
            error: (err) => {
                this._defaultRoute.error(err);
            }
        });
    }
    /**
     * Creates a cold observable that, when subscribed to, will send the given WAMP message via the transport and complete once the message has been sent.
     * @param {WampMessage.Any} msg The message to send.
     */
    send$(msg) {
        return rxjs_1.of(null).pipe(operators_1.flatMap(() => {
            let loose = msg.toTransportFormat();
            return this.transport.send$(loose);
        }));
    }
    /**
     * When subscribed to, creates a route for all protocol messages.
     * When unsubscribed, deletes the route.
     * @returns {Observable<WampMessage.Any>}
     */
    get messages$() {
        return rxjs_1.merge(this.expect$([]));
    }
    /**
     * When subscribed to, creates a route for protocol messages with fields matching the given prefix.
     * When unsubscribed, deletes the route.
     * @param {WampArray} prefixKey
     * @returns {Observable<WampMessage.Any>}
     */
    expect$(prefixKey) {
        return rxjs_1.Observable.create(sub => {
            let inv = {
                key: prefixKey,
                next(x) {
                    sub.next(x);
                },
                complete() {
                    sub.complete();
                },
                error(err) {
                    sub.error(err);
                }
            };
            this._router.insertRoute(inv);
            return {
                unsubscribe: () => __awaiter(this, void 0, void 0, function* () {
                    this._router.removeRoute(inv);
                })
            };
        });
    }
    /**
     * When called, it will invalidate all existing routes by causing them to error with the given object.
     * This should be used when terminating a session in order to violate all routes.
     * @param error
     */
    invalidateAllRoutes(error) {
        // The wait(0) thing is needed to prevent a bug in rxjs where it seems that
        // causing a source observable to error while in a flatMap will hang the observable
        // TODO: Report bug
        ext_promise_1.MyPromise.wait(0).then(() => {
            this._onClosed.complete();
            let routes = this._router.matchAll();
            for (let route of routes) {
                route.error(error);
            }
        });
    }
    /**
     * Like [[expect$]], except that this defines several routes with a union.
     * @see expect$
     * @param routes
     */
    expectAny$(...routes) {
        return rxjs_1.merge(...routes.map(rt => this.expect$(rt)));
    }
}
exports.WampProtocolClient = WampProtocolClient;
//# sourceMappingURL=wamp-protocol-client.js.map