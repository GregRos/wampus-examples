"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const message_type_1 = require("../protocol/message.type");
const _ = require("lodash");
/**
 * A component that routes WAMP protocol messages to code that expects them.
 */
class PrefixRouter {
    constructor() {
        this._root = null;
    }
    /**
     * Returns the total number of registered routes.
     */
    count() {
        if (!this._root)
            return 0;
        let rec = (x) => {
            return x.match.length + Array.from(x.next.values()).reduce((tot, cur) => tot + rec(cur), 0);
        };
        return rec(this._root);
    }
    /**
     * Returns all routes.
     */
    matchAll() {
        return this.reverseMatch([]);
    }
    /**
     * Matches routes where the given key is a prefix of the route's key. Reverse matching.
     * @param key The given key to match against the routes.
     */
    reverseMatch(key) {
        let routes = [];
        function rec(cur, index) {
            if (!cur)
                return;
            if (index >= key.length) {
                routes.push(...cur.match);
                [...cur.next.values()].forEach(next => rec(next, index + 1));
            }
            else {
                let next = cur.next.get(key[index]);
                if (next) {
                    rec(next, index + 1);
                }
            }
        }
        rec(this._root, 0);
        return routes;
    }
    /**
     * Matches all routes where the route's key is a prefix of the given key.
     * @param keys
     */
    match(keys) {
        if (keys[0] === message_type_1.WampType.INVOCATION) {
            //ugly but works
            let a = keys[2];
            keys[2] = keys[1];
            keys[1] = a;
        }
        let routes = [];
        let rec = function (cur, index) {
            if (!cur)
                return;
            for (let target of cur.match) {
                routes.push(target);
            }
            if (index >= keys.length) {
                return;
            }
            let next = cur.next.get(keys[index]);
            if (!next)
                return cur;
            rec(next, index + 1);
        };
        rec(this._root, 0);
        return routes;
    }
    /**
     * Inserts route into the router.
     * @param target The prefix route.
     */
    insertRoute(target) {
        let keys = target.key;
        _.defaults(target, {
            error() { },
            next() { },
            complete() { }
        });
        let rec = (cur, index) => {
            if (!cur) {
                cur = {
                    match: [],
                    next: new Map()
                };
            }
            if (keys.length <= index) {
                cur.match.push(target);
                return cur;
            }
            let nextIndex = cur.next.get(keys[index]);
            nextIndex = rec(nextIndex, index + 1);
            cur.next.set(keys[index], nextIndex);
            return cur;
        };
        this._root = rec(this._root, 0);
    }
    /**
     * Removes a route from the internal index. Note that this won't do anything to the route object itself, so it may still expect input.
     * @param target The route to remove, by reference.
     */
    removeRoute(target) {
        let keys = target.key;
        let rec = (cur, index) => {
            if (!cur)
                return null;
            if (keys.length <= index) {
                let foundIndex = cur.match.indexOf(target);
                if (foundIndex === -1)
                    return cur;
                cur.match.splice(foundIndex, 1);
                if (cur.match.length === 0 && cur.next.size === 0) {
                    return null;
                }
                else {
                    return cur;
                }
            }
            let next = cur.next.get(keys[index]);
            if (!next)
                return cur;
            next = rec(next, index + 1);
            if (!next) {
                cur.next.delete(keys[index]);
            }
            else {
                cur.next.set(keys[index], next);
            }
            return cur;
        };
        this._root = rec(this._root, 0);
    }
}
exports.PrefixRouter = PrefixRouter;
//# sourceMappingURL=prefix-router.js.map