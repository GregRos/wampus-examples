"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @module core
 */
const messages_1 = require("../protocol/messages");
const message_type_1 = require("../protocol/message.type");
const errors_1 = require("../errors/errors");
const uris_1 = require("../protocol/uris");
const types_1 = require("../errors/types");
const routes_1 = require("../routing/routes");
const options_1 = require("../protocol/options");
const wamp_protocol_client_1 = require("../routing/wamp-protocol-client");
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const ext_promise_1 = require("../../utils/ext-promise");
const rxjs_operators_1 = require("../../utils/rxjs-operators");
const hello_details_1 = require("../hello-details");
const reader_1 = require("../protocol/reader");
const default_factory_1 = require("./default-factory");
const internal_compatibility_1 = require("rxjs/internal-compatibility");
const route_completion_1 = require("./route-completion");
const _ = require("lodash");
var WM = messages_1.WampMessage;
let factory = default_factory_1.DefaultMessageFactory;
/**
 * The Wampus class that implements most WAMP session logic.
 * This class is usually used via a wrapper session that enriches the session object's functionality.
 */
class WampusCoreSession {
    constructor(never) {
        this._isClosing = false;
    }
    get realm() {
        return this.config.realm;
    }
    get isActive() {
        return !this._isClosing;
    }
    get details() {
        return this._welcomeDetails;
    }
    static create(config) {
        return __awaiter(this, void 0, void 0, function* () {
            // 1. Receive transport
            // 2. Handshake
            // 3. Wait until session closed:
            //      On close: Initiate goodbye sequence.
            let transport = yield config.transport();
            let reader = new reader_1.MessageReader();
            let messenger = wamp_protocol_client_1.WampProtocolClient.create(transport, x => reader.parse(x));
            let session = new WampusCoreSession(null);
            session.config = config;
            session.protocol = messenger;
            let serverDroppedConnection$ = rxjs_1.onErrorResumeNext(messenger.onClosed.pipe(operators_1.flatMap(x => {
                return rxjs_1.concat(rxjs_1.timer(0), rxjs_1.defer(() => {
                    messenger.invalidateAllRoutes(new route_completion_1.WampusRouteCompletion(route_completion_1.WampusCompletionReason.RouterDisconnect));
                    session._isClosing = true;
                    return;
                }));
            })), rxjs_1.EMPTY);
            serverDroppedConnection$.subscribe();
            let getSessionFromShake$ = session._handshake$(config.authenticator).pipe(operators_1.map(welcome => {
                session.sessionId = welcome.sessionId;
                session._welcomeDetails = welcome.details;
                session._registerControlRoutes().subscribe();
            }));
            return rxjs_1.concat(getSessionFromShake$).pipe(operators_1.mapTo(session), operators_1.take(1)).toPromise();
        });
    }
    /**
     * Registers a procedure and returns a registration ticket.
     * @param wArgs The arguments for registering the procedure, including the function that is invoked when the procedure is called.
     * @returns A promise that resolves with the ticket once the registration is successful.
     */
    register(wArgs) {
        return __awaiter(this, void 0, void 0, function* () {
            let { options, name } = wArgs;
            let msg = factory.register(options, name);
            let self = this;
            if (!this.isActive)
                throw errors_1.Errs.sessionClosed(msg);
            options = options || {};
            let { _welcomeDetails } = this;
            let features = _welcomeDetails.roles.dealer.features;
            // Make sure the router's WELCOME message supports all the features specified in options and throw an error otherwise.
            if (options.disclose_caller && !features.caller_identification) {
                throw errors_1.Errs.routerDoesNotSupportFeature(msg, uris_1.AdvProfile.Call.CallerIdentification);
            }
            if (options.match && !features.pattern_based_registration) {
                throw errors_1.Errs.routerDoesNotSupportFeature(msg, uris_1.AdvProfile.Call.PatternRegistration);
            }
            if (options.invoke && options.invoke !== options_1.InvocationPolicy.Single && !features.shared_registration) {
                throw errors_1.Errs.routerDoesNotSupportFeature(msg, uris_1.AdvProfile.Call.SharedRegistration);
            }
            let sending$ = this.protocol.send$(msg).pipe(operators_1.mergeMapTo(rxjs_1.EMPTY));
            // Expect a [REGISTERED] or [ERROR, REGISTER] message
            let expectRegisteredOrError$ = this.protocol.expectAny$(routes_1.Routes.registered(msg.requestId), routes_1.Routes.error(message_type_1.WampType.REGISTER, msg.requestId)).pipe(operators_1.catchError(err => {
                if (err instanceof route_completion_1.WampusRouteCompletion) {
                    throw errors_1.Errs.sessionIsClosing(msg);
                }
                throw err;
            }));
            // Operator - in case of an ERROR message, throw an exception.
            let failOnError = operators_1.map((x) => {
                if (x instanceof messages_1.WampMessage.Error) {
                    this._throwCommonError(msg, x);
                    switch (x.error) {
                        case uris_1.WampUri.Error.ProcAlreadyExists:
                            throw errors_1.Errs.Register.procedureAlreadyExists(msg.procedure, x);
                        default:
                            throw errors_1.Errs.Register.error(msg.procedure, x);
                    }
                }
                return x;
            });
            let signalUnregistered = new rxjs_1.Subject();
            // Operator - When Registered message is received, start listening for invocations.
            let whenRegisteredReceived = operators_1.map((registered) => {
                // Expect INVOCATION message
                let expectInvocation$ = this.protocol.expectAny$(routes_1.Routes.invocation(registered.registrationId)).pipe(operators_1.catchError(err => {
                    if (err instanceof route_completion_1.WampusRouteCompletion) {
                        closing = Promise.resolve();
                        return rxjs_1.EMPTY;
                    }
                    throw err;
                }), operators_1.takeUntil(signalUnregistered));
                let closing;
                // Finalize by closing the REGISTRATION when the outer observable is abandoned.
                let close = () => __awaiter(this, void 0, void 0, function* () {
                    if (this._isClosing)
                        return;
                    let unregisterMsg = factory.unregister(registered.registrationId);
                    let sendingUnregister$ = this.protocol.send$(unregisterMsg);
                    // Wait for a UNREGISTERED or ERROR;UNREGISTER message.
                    let receivedUnregistered$ = this.protocol.expectAny$(routes_1.Routes.unregistered(unregisterMsg.requestId), routes_1.Routes.error(message_type_1.WampType.UNREGISTER, unregisterMsg.requestId));
                    let failOnUnregisterError = operators_1.map((x) => {
                        signalUnregistered.next();
                        if (x instanceof messages_1.WampMessage.Error) {
                            this._throwCommonError(unregisterMsg, x);
                            switch (x.error) {
                                case uris_1.WampUri.Error.NoSuchRegistration:
                                    throw errors_1.Errs.Unregister.registrationDoesntExist(name, x);
                                default:
                                    throw errors_1.Errs.Unregister.other(name, x);
                            }
                        }
                        signalUnregistered.next();
                        return x;
                    });
                    // Send UNREGISTER and listen for messages at the same time
                    return rxjs_1.merge(sendingUnregister$, receivedUnregistered$).pipe(failOnUnregisterError, operators_1.take(1), operators_1.catchError(err => {
                        if (err instanceof route_completion_1.WampusRouteCompletion) {
                            return rxjs_1.EMPTY;
                        }
                        throw err;
                    })).toPromise();
                });
                // Operator - Received INVOCATION message.
                let whenInvocationReceived = operators_1.map((invocationMsg) => {
                    // Expect INTERRUPT message for cancellation
                    let completeInterrupt = new rxjs_1.Subject();
                    let interruptRequest$ = this.protocol.expectAny$([message_type_1.WampType.INTERRUPT, invocationMsg.requestId])
                        .pipe(operators_1.map(x => x), operators_1.map(x => {
                        return {
                            received: new Date(),
                            options: x.options,
                            source: procInvocationTicket,
                            type: "cancel"
                        };
                    }));
                    // Fabricate a cancellation token if the timeout is elapsed.
                    let timeout = invocationMsg.options.timeout >= 0 ? rxjs_1.timer(invocationMsg.options.timeout) : rxjs_1.NEVER;
                    let timeoutEvent$ = timeout.pipe(operators_1.map(x => {
                        return {
                            received: new Date(),
                            options: {},
                            source: procInvocationTicket,
                            type: "timeout"
                        };
                    }));
                    let anyInterrupt$ = rxjs_1.merge(interruptRequest$, timeoutEvent$);
                    let expectInterrupt = anyInterrupt$
                        .pipe(operators_1.take(1), operators_1.takeUntil(completeInterrupt), operators_1.catchError(err => {
                        if (err instanceof route_completion_1.WampusRouteCompletion) {
                            return rxjs_1.EMPTY;
                        }
                        throw err;
                    }), rxjs_operators_1.publishReplayAutoConnect());
                    let isHandled = false;
                    // Send the selected WAMP message as a reply to the invocation
                    let send$ = (msg) => {
                        if (!this.isActive)
                            return rxjs_1.throwError(errors_1.Errs.sessionIsClosing(msg));
                        // If the message is progress, make sure this invocation supports progress
                        if (msg instanceof messages_1.WampMessage.Yield && msg.options.progress) {
                            if (!invocationMsg.options.receive_progress) {
                                return rxjs_1.throwError(errors_1.Errs.Register.doesNotSupportProgressReports(name));
                            }
                        }
                        // Make sure the user can't send a response twice.
                        if (isHandled) {
                            return rxjs_1.throwError(errors_1.Errs.Register.cannotSendResultTwice(name));
                        }
                        // If this response finishes the invocation, close the route waiting for an INTERRUPT
                        // and mark handled.
                        if (msg instanceof messages_1.WampMessage.Error || msg instanceof messages_1.WampMessage.Yield && !msg.options.progress) {
                            completeInterrupt.next();
                            isHandled = true;
                        }
                        return this.protocol.send$(msg);
                    };
                    // Create an invocation ticket.
                    let procInvocationTicket = {
                        source: procRegistrationTicket,
                        error(err) {
                            if (typeof err !== "object") {
                                throw errors_1.Errs.Register.resultIncorrectFormat(name, err);
                            }
                            let { args, error, kwargs, details } = err;
                            return send$(factory.error(message_type_1.WampType.INVOCATION, invocationMsg.requestId, details, error, args, kwargs)).toPromise();
                        },
                        return(obj) {
                            if (typeof obj !== "object") {
                                throw errors_1.Errs.Register.resultIncorrectFormat(name, obj);
                            }
                            let { args, kwargs, options } = obj;
                            return send$(factory.yield(invocationMsg.requestId, options, args, kwargs)).toPromise();
                        },
                        progress(args) {
                            args.options = args.options || {};
                            args.options.progress = true;
                            return this.return(args);
                        },
                        get isHandled() {
                            return isHandled;
                        },
                        get cancellation() {
                            return expectInterrupt;
                        },
                        args: invocationMsg.args,
                        kwargs: invocationMsg.kwargs,
                        options: invocationMsg.options,
                        name: invocationMsg.options.procedure || name,
                        invocationId: invocationMsg.requestId
                    };
                    return procInvocationTicket;
                });
                // Bind the case when an invocation is received to the expectation for the INVOCATION message.
                let invocations$ = expectInvocation$.pipe(whenInvocationReceived);
                // Create the registration ticket
                let procRegistrationTicket = {
                    invocations: invocations$.pipe(rxjs_operators_1.publishAutoConnect()),
                    close() {
                        if (closing)
                            return closing;
                        closing = close();
                        return closing;
                    },
                    info: {
                        name,
                        options,
                        registrationId: registered.registrationId
                    },
                    get isOpen() {
                        return !closing && !self._isClosing;
                    }
                };
                return procRegistrationTicket;
            });
            let result = rxjs_1.merge(sending$, expectRegisteredOrError$)
                .pipe(operators_1.takeWhile(x => x !== null))
                .pipe(failOnError, operators_1.take(1))
                .pipe(whenRegisteredReceived);
            return result.toPromise();
        });
    }
    /**
     * Publish an event to a topic.
     * @param wArgs All the arguments required
     */
    publish(wArgs) {
        return __awaiter(this, void 0, void 0, function* () {
            let { options, args, kwargs, name } = wArgs;
            let msg = factory.publish(options, name, args, kwargs);
            if (!this.isActive)
                throw errors_1.Errs.sessionClosed(msg);
            options = options || {};
            let features = this._welcomeDetails.roles.broker.features;
            // Make sure the event's options are supported by the broker
            if ((options.eligible || options.eligible_authid || options.eligible_authrole
                || options.exclude || options.exclude_authid || options.exclude_authrole) && !features.subscriber_blackwhite_listing) {
                throw errors_1.Errs.routerDoesNotSupportFeature(msg, uris_1.AdvProfile.Subscribe.SubscriberBlackWhiteListing);
            }
            if (options.disclose_me && !features.publisher_identification) {
                throw errors_1.Errs.routerDoesNotSupportFeature(msg, uris_1.AdvProfile.Subscribe.PublisherIdentification);
            }
            if (options.exclude_me === false && !features.publisher_exclusion) {
                throw errors_1.Errs.routerDoesNotSupportFeature(msg, uris_1.AdvProfile.Subscribe.PublisherExclusion);
            }
            return rxjs_1.defer(() => {
                let expectAcknowledge$;
                // If acknowledgement is enabled, we need to wait for a message...
                if (options.acknowledge) {
                    // Create a route for PUBLISHED | ERROR, PUBLISH
                    let expectPublishedOrError$ = this.protocol.expectAny$(routes_1.Routes.published(msg.requestId), routes_1.Routes.error(message_type_1.WampType.PUBLISH, msg.requestId)).pipe(operators_1.take(1), operators_1.catchError(err => {
                        if (err instanceof route_completion_1.WampusRouteCompletion) {
                            // If the route is completed, throw an error (the event could not be published).
                            throw errors_1.Errs.sessionIsClosing(msg);
                        }
                        throw err;
                    }));
                    // If an error is received, handle it.
                    let failOnError = operators_1.map((response) => {
                        if (response instanceof WM.Error) {
                            this._throwCommonError(msg, response);
                            throw errors_1.Errs.Publish.unknown(msg.topic, response);
                        }
                        return response;
                    });
                    expectAcknowledge$ = expectPublishedOrError$.pipe(failOnError, operators_1.mergeMapTo(rxjs_1.EMPTY));
                }
                else {
                    // If acknowledgelement is not enabled, use EMPTY.
                    expectAcknowledge$ = rxjs_1.EMPTY;
                }
                // Send the PUBLISH message
                let sendingPublish$ = this.protocol.send$(msg);
                if (!options.acknowledge) {
                    // If acknowledgement is disabled, swallow any errors fom a failed send$ call
                    sendingPublish$ = sendingPublish$.pipe(operators_1.catchError(err => {
                        return rxjs_1.EMPTY;
                    }));
                }
                // Send the PUBLISH message and set up the route for expecting acknowledgement at the same time
                // to maintain uniformity
                return rxjs_1.merge(sendingPublish$, expectAcknowledge$);
            }).toPromise();
        });
    }
    /**
     * Subscribes to a topic and returns a subscription ticket that exposes an observable which will fire every time the subscription is triggered.
     * @param {WampSubscribeOptions} wArgs All the info necessary to subscribe to a topic.
     * @returns A promise that resolves with the subscription ticket when the subscription has been established.
     */
    topic(wArgs) {
        return __awaiter(this, void 0, void 0, function* () {
            let { options, name } = wArgs;
            let msg = factory.subscribe(options, name);
            let self = this;
            if (!this.isActive)
                throw errors_1.Errs.sessionClosed(msg);
            options = options || {};
            // Make sure the session supports the subscription features.
            let features = this._welcomeDetails.roles.broker.features;
            if (options.match && !features.pattern_based_subscription) {
                throw errors_1.Errs.routerDoesNotSupportFeature(msg, uris_1.AdvProfile.Subscribe.PatternBasedSubscription);
            }
            let expectSubscribedOrError$ = rxjs_1.defer(() => {
                let sending$ = this.protocol.send$(msg);
                // Creates a expectation for the SUBSCRIBED message
                let expectSubscribedOrError$ = this.protocol.expectAny$(routes_1.Routes.subscribed(msg.requestId), routes_1.Routes.error(message_type_1.WampType.SUBSCRIBE, msg.requestId));
                // Throw an error if an ERROR message is received
                let failOnErrorOrCastToSubscribed = operators_1.map((x) => {
                    if (x instanceof WM.Error) {
                        // No SUBSCRIBE-specific errors spring to mind
                        this._throwCommonError(msg, x);
                        throw errors_1.Errs.Subscribe.other(name, x);
                    }
                    return x;
                });
                // Send the SUBSCRIBE message and set up the route for the reply at the same time
                return rxjs_1.merge(sending$, expectSubscribedOrError$).pipe(failOnErrorOrCastToSubscribed);
            }).pipe(operators_1.catchError(err => {
                // If the route is being forced closed, throw an error.
                if (err instanceof route_completion_1.WampusRouteCompletion) {
                    throw errors_1.Errs.sessionIsClosing(msg);
                }
                throw err;
            }));
            // Once SUBSCRIBED is received, create a ticket for the subscription.
            let whenSubscribedCreateTicket = operators_1.map((subscribed) => {
                let unsub = factory.unsubscribe(subscribed.subscriptionId);
                // Create route for EVENT messages.
                let expectEvents$ = this.protocol.expectAny$(routes_1.Routes.event(subscribed.subscriptionId)).pipe(operators_1.catchError(err => {
                    // If the route is forced closed, just pretend the subscription has been closed.
                    if (err instanceof route_completion_1.WampusRouteCompletion) {
                        closing = Promise.resolve();
                        return rxjs_1.EMPTY;
                    }
                    throw err;
                }));
                let closeSignal = new rxjs_1.Subject();
                let closing;
                // This is called when the subscription is closed.
                let close = () => __awaiter(this, void 0, void 0, function* () {
                    // If the session is closing, ignore this.
                    if (this._isClosing)
                        return;
                    // Create route for UNSUBSCRIBED or ERROR, UNSUBSCRIBE
                    let expectUnsubscribedOrError$ = this.protocol.expectAny$(routes_1.Routes.unsubscribed(unsub.requestId), routes_1.Routes.error(message_type_1.WampType.UNSUBSCRIBE, unsub.requestId));
                    // Handle errors, if any
                    let failOnUnsubscribedError = operators_1.map((msg) => {
                        closeSignal.next();
                        if (msg instanceof messages_1.WampMessage.Error) {
                            this._throwCommonError(unsub, msg);
                            switch (msg.error) {
                                case uris_1.WampUri.Error.NoSuchSubscription:
                                    throw errors_1.Errs.Unsubscribe.subDoesntExist(msg, name);
                                default:
                                    throw errors_1.Errs.Unsubscribe.other(msg, name);
                            }
                        }
                        return msg;
                    });
                    let sendUnsub$ = this.protocol.send$(unsub);
                    // Actually send the UNSUBSCRIBE message and set up the route for the repy.
                    let total = rxjs_1.merge(sendUnsub$, expectUnsubscribedOrError$).pipe(failOnUnsubscribedError, operators_1.take(1), operators_1.catchError(err => {
                        // If a route is forced closed, just pretend we've received a reply.
                        if (err instanceof route_completion_1.WampusRouteCompletion) {
                            return rxjs_1.EMPTY;
                        }
                        throw err;
                    }));
                    return total.toPromise();
                });
                // Map EVENT messages to objects.
                let mapToLibraryEvent = operators_1.map((x) => {
                    let a = {
                        args: x.args,
                        details: x.details,
                        kwargs: x.kwargs,
                        source: eventSubscriptionTicket
                    };
                    return a;
                });
                // Create the subscription ticket.
                let eventSubscriptionTicket = {
                    close() {
                        if (closing)
                            return closing;
                        closing = close();
                        return closing;
                    },
                    // Here we map the EVENT messages to objects
                    events: expectEvents$.pipe(mapToLibraryEvent).pipe(operators_1.takeUntil(closeSignal), rxjs_operators_1.publishAutoConnect()),
                    info: {
                        subscriptionId: subscribed.subscriptionId,
                        name: name,
                        options: options
                    },
                    get isOpen() {
                        return !closing && !self._isClosing;
                    }
                };
                return eventSubscriptionTicket;
            });
            return expectSubscribedOrError$.pipe(operators_1.take(1), whenSubscribedCreateTicket).toPromise();
        });
    }
    /**
     * Calls a WAMP procedure
     * @param wArgs All the arguments required to call a procedure.
     */
    call(wArgs) {
        try {
            let { options, name, args, kwargs } = wArgs;
            let features = this._welcomeDetails.roles.dealer.features;
            // Wampus calls support progress by default
            options = _.defaults(options, {
                receive_progress: features.progressive_call_results
            });
            let msg = factory.call(options, name, args, kwargs);
            // If the session is closed, end here.
            if (!this.isActive)
                throw errors_1.Errs.sessionClosed(msg);
            let self = this;
            let canceling;
            // Check call options are compatible with the deaqler's features.
            if (options.disclose_me && !features.caller_identification) {
                throw errors_1.Errs.routerDoesNotSupportFeature(msg, uris_1.AdvProfile.Call.CallerIdentification);
            }
            if (options.receive_progress && !features.progressive_call_results) {
                throw errors_1.Errs.routerDoesNotSupportFeature(msg, uris_1.AdvProfile.Call.ProgressReports);
            }
            if (options.timeout && !features.call_timeout) {
                throw errors_1.Errs.routerDoesNotSupportFeature(msg, uris_1.AdvProfile.Call.CallTimeouts);
            }
            // Check if this message will finish the call to mark it as non-cancellable.
            let maybeTooLateToCancel = operators_1.tap((x) => {
                if (x instanceof WM.Error || x instanceof WM.Result && !x.details.progress) {
                    canceling = Promise.resolve();
                }
            });
            // Handle an error or continue
            let failOnError = operators_1.map((x) => {
                if (x instanceof messages_1.WampMessage.Error) {
                    this._throwCommonError(msg, x);
                    switch (x.error) {
                        case uris_1.WampUri.Error.NoSuchProcedure:
                            throw errors_1.Errs.Call.noSuchProcedure(msg.procedure, x);
                        case uris_1.WampUri.Error.NoEligibleCallee:
                            throw errors_1.Errs.Call.noEligibleCallee(msg.procedure, x);
                        case uris_1.WampUri.Error.DisallowedDiscloseMe:
                            throw errors_1.Errs.Call.optionDisallowedDiscloseMe(msg.procedure, x);
                        case uris_1.WampUri.Error.Canceled:
                            throw errors_1.Errs.Call.canceled(name, x);
                        case uris_1.WampUri.Error.InvalidArgument:
                            throw errors_1.Errs.Call.invalidArgument(name, x);
                    }
                    if (x.error === uris_1.WampUri.Error.RuntimeError || !x.error.startsWith(uris_1.WampUri.Error.Prefix)) {
                        throw errors_1.Errs.Call.errorResult(name, x);
                    }
                    throw errors_1.Errs.Call.other(name, x);
                }
                return x;
            });
            // Map a RESULT message to an object.
            let toLibraryResult = operators_1.map((x) => {
                return {
                    args: x.args,
                    kwargs: x.kwargs,
                    isProgress: x.details.progress || false,
                    details: x.details,
                    name: name,
                    source: callTicket
                };
            });
            // Set up the route for (RESULT | ERROR, CALL)
            // And pass it through the operators defined above
            let expectResultOrError = self.protocol.expectAny$(routes_1.Routes.result(msg.requestId), routes_1.Routes.error(message_type_1.WampType.CALL, msg.requestId)).pipe(maybeTooLateToCancel, operators_1.catchError(err => {
                if (err instanceof route_completion_1.WampusRouteCompletion) {
                    // If the route is being closed, throw an error to indicate calling failed
                    throw errors_1.Errs.sessionIsClosing(msg);
                }
                throw err;
            }), failOnError, toLibraryResult).pipe(rxjs_operators_1.publishAutoConnect());
            // Send the CALL message and cache the result. We'll need to refer to this observable in the future.
            let sending = this.protocol.send$(msg).pipe(rxjs_operators_1.publishAutoConnect());
            // Merge sending and creating the route for the reply, and set up the conditions for non-error call completion.
            let allStream = rxjs_1.merge(expectResultOrError, sending)
                .pipe(rxjs_operators_1.skipAfter((x) => !x.isProgress));
            // Start the cancelling flow
            let startCancelling = (cancel) => rxjs_1.defer(() => __awaiter(this, void 0, void 0, function* () {
                if (this._isClosing)
                    return;
                let sendCancel$ = this.protocol.send$(cancel);
                // Send the CANCEL message
                // And also create a route for (RESULT | ERROR, CALL)
                return rxjs_1.merge(sendCancel$, self.protocol.expectAny$(routes_1.Routes.result(msg.requestId), routes_1.Routes.error(message_type_1.WampType.CALL, msg.requestId)).pipe(rxjs_operators_1.skipAfter(x => {
                    // If canelling is successful, the route will yield ERROR, CALL so this will be used both in the regular flow
                    // and also as a response to the CANCEL message.
                    // If cancelling comes too late, the route will yield a non-progress RESULT, which will also be a response to the CANCEL message.
                    return x instanceof WM.Result && !x.details.progress || x instanceof WM.Error;
                }), operators_1.catchError(err => {
                    // If the route is forced closed, stop the cancelling flow and assume it finished.
                    if (err instanceof route_completion_1.WampusRouteCompletion) {
                        return rxjs_1.EMPTY;
                    }
                    throw err;
                }), operators_1.map(msg => {
                    // Swallow any result
                }))).toPromise();
            }));
            // Record all messages
            let progressStream = allStream.pipe(rxjs_operators_1.publishAutoConnect());
            // Create a call ticket
            let callTicket = {
                progress: progressStream,
                close(mode) {
                    // Here we'll begin the cancelling flow
                    let cancel = factory.cancel(msg.requestId, {
                        mode: mode || options_1.CancelMode.Kill
                    });
                    // First we need to make sure cancelling is supported
                    if (!features.call_canceling) {
                        return Promise.reject(errors_1.Errs.routerDoesNotSupportFeature(cancel, uris_1.AdvProfile.Call.CallCancelling));
                    }
                    // If cancelling is already being performed, just return the existing promise.
                    if (canceling)
                        return canceling;
                    // Otherwise, assign the promise to a cancelling flow.
                    return canceling = rxjs_1.concat(sending, startCancelling(cancel)).toPromise().then(() => {
                    });
                },
                get isOpen() {
                    return !canceling && !self._isClosing;
                },
                info: {
                    callId: msg.requestId,
                    name,
                    options
                }
            };
            return callTicket;
        }
        catch (err) {
            // We want to deal uniformally with errors thrown by the called code directly
            // And errors encountered in the async observable flow. That's why we turn a sync error here
            // into an async one.
            return {
                close() {
                    return __awaiter(this, void 0, void 0, function* () {
                    });
                },
                progress: rxjs_1.throwError(err),
                get isOpen() {
                    return false;
                },
                info: Object.assign({}, wArgs, { callId: undefined })
            };
        }
    }
    close() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._close$({}, uris_1.WampUri.CloseReason.GoodbyeAndOut, false).toPromise();
        });
    }
    _throwCommonError(source, err) {
        switch (err.error) {
            case uris_1.WampUri.Error.NotAuthorized:
                throw errors_1.Errs.notAuthorized(source, err);
            case uris_1.WampUri.Error.InvalidUri:
                throw errors_1.Errs.invalidUri(source, err);
            case uris_1.WampUri.Error.NetworkFailure:
                throw errors_1.Errs.networkFailure(source, err);
            case uris_1.WampUri.Error.OptionNotAllowed:
                throw errors_1.Errs.optionNotAllowed(source, err);
        }
    }
    _close$(details, reason, abrupt) {
        // If we're already closing, return an EMPTY
        if (this._isClosing)
            return rxjs_1.EMPTY;
        // Mark _isClosing ourselves
        this._isClosing = true;
        // If told to close using ABORT
        if (abrupt) {
            // We do these steps in sequence. First we force close all routes, and then we send an ABORT signal.
            // We do that because sending ABORT will end up in the transport being closed, and we want to handle
            // Forcing the routes closed correctly ourselves to avoid issues.
            // Finally, we terminate the connection ourselves
            return rxjs_1.concat(this._closeRoutes$(new route_completion_1.WampusRouteCompletion(route_completion_1.WampusCompletionReason.SelfAbort)), this._abort$(details, reason), rxjs_1.defer(() => __awaiter(this, void 0, void 0, function* () {
                return this.protocol.transport.close();
            })));
        }
        // Here we deal with GOODBYE-type termination.
        // We set a timeout for the GOODBYE response to arrive.
        let timeout = rxjs_1.timer(this.config.timeout).pipe(operators_1.flatMap(() => {
            throw errors_1.Errs.Leave.goodbyeTimedOut();
        }));
        // We take the first: GOODBYE or timeout.
        let expectGoodbyeOrTimeout = rxjs_1.race(this._goodbye$(details, reason), timeout).pipe(operators_1.catchError(err => {
            // If the transport is closed before the _goodbye$ workflow is finished, just stop.
            if (err instanceof types_1.WampusNetworkError) {
                return rxjs_1.EMPTY;
            }
            // TODO: Handle this without console.warn
            console.warn("Error when saying GOODBYE. Going to say ABORT.", err);
            // Going to ABORT since GOODBYE failed.
            return this._abort$(details, reason);
        }), operators_1.take(1));
        // The same as in the timing for abrupt termination
        // We first close the routes and only then begin the GOODBYE sequence
        // This is also true because routes defined earlier are set up to receive GOODBYE to detect a server-initiated polite termination
        // And if we didn't close the routes here, it would get confused.
        return rxjs_1.concat(this._closeRoutes$(new route_completion_1.WampusRouteCompletion(route_completion_1.WampusCompletionReason.SelfGoodbye)), expectGoodbyeOrTimeout, rxjs_1.defer(() => __awaiter(this, void 0, void 0, function* () {
            return this.protocol.transport.close();
        })));
    }
    _abortDueToProtoViolation(message) {
        return this._close$({
            message
        }, uris_1.WampUri.Error.ProtoViolation, true);
    }
    _closeRoutes$(err) {
        // TODO: Rework the timing of this code
        // Note that the timing here is really fragile, because we might end up doing something like:
        // expectRoute$(x).flatMap(x => _closeRoutes$())
        // Which basically means that as part of the inner obervable returned by flatMap, the outer observable `expectRoute$(x)` is going to error
        // So a sequence of timeouts is used that may not be portable or even a good idea.
        return rxjs_1.defer(() => __awaiter(this, void 0, void 0, function* () {
            this.protocol.invalidateAllRoutes(err);
            // We give the routes time to close before continuing
            yield ext_promise_1.MyPromise.wait(0);
        })).pipe(operators_1.take(1));
    }
    _handleClose$(msg) {
        // This code is for handling server-initiated closing.
        if (this._isClosing)
            return rxjs_1.EMPTY;
        this._isClosing = true;
        if (msg instanceof messages_1.WampMessage.Abort) {
            // The closing is abrupt. The server doesn't want any reply and may terminate the connection immediately.
            return rxjs_1.concat(this._closeRoutes$(new route_completion_1.WampusRouteCompletion(route_completion_1.WampusCompletionReason.RouterAbort, msg)), rxjs_1.defer(() => __awaiter(this, void 0, void 0, function* () {
                yield this.protocol.transport.close();
            })));
        }
        else {
            let echo$ = this.protocol.send$(factory.goodbye({
                message: "Goodbye received"
            }, uris_1.WampUri.CloseReason.GoodbyeAndOut));
            let x = rxjs_1.concat(echo$, this._closeRoutes$(new route_completion_1.WampusRouteCompletion(route_completion_1.WampusCompletionReason.RouterGoodbye, msg)), rxjs_1.defer(() => __awaiter(this, void 0, void 0, function* () {
                yield this.protocol.transport.close();
            })));
            return x;
        }
    }
    _abort$(details, reason) {
        let errorOnTimeout = operators_1.timeoutWith(this.config.timeout, rxjs_1.throwError(errors_1.Errs.Leave.networkErrorOnAbort(new Error("Timed Out"))));
        let sending$ = this.protocol.send$(factory.abort(details, reason));
        let all$ = sending$.pipe(errorOnTimeout, operators_1.catchError(() => {
            console.warn("Network error on ABORT.");
            return rxjs_1.EMPTY;
        }));
        return rxjs_1.concat(all$);
    }
    _goodbye$(details, reason) {
        let myGoodbye = factory.goodbye(details, reason);
        let sending$ = this.protocol.send$(myGoodbye);
        let expectingByeOrError$ = this.protocol.expectAny$(routes_1.Routes.abort, routes_1.Routes.goodbye);
        let failOnError = operators_1.map((x) => {
            if (x instanceof messages_1.WampMessage.Goodbye) {
                return x;
            }
        });
        return rxjs_1.merge(sending$, rxjs_1.concat(expectingByeOrError$).pipe(failOnError));
    }
    _handshake$(authenticator) {
        let messenger = this.protocol;
        let config = this.config;
        let helloDetails = _.cloneDeep(hello_details_1.wampusHelloDetails);
        if (config.helloDetails) {
            config.helloDetails(helloDetails);
        }
        let hello = factory.hello(config.realm, helloDetails);
        let handleAuthentication = operators_1.flatMap((msg) => {
            if (msg instanceof WM.Challenge) {
                if (!authenticator) {
                    throw errors_1.Errs.Handshake.noAuthenticator(msg);
                }
                else {
                    let simplifiedEvent = {
                        extra: msg.extra,
                        authMethod: msg.authMethod
                    };
                    return internal_compatibility_1.fromPromise(Promise.resolve(authenticator(simplifiedEvent))).pipe(operators_1.flatMap(response => {
                        return this.protocol.send$(factory.authenticate(response.signature, response.extra));
                    }));
                }
            }
            return rxjs_1.of(msg);
        });
        let handleWelcome = operators_1.map((msg) => {
            if (msg instanceof WM.Abort) {
                switch (msg.reason) {
                    case uris_1.WampUri.Error.NoSuchRealm:
                        throw errors_1.Errs.Handshake.noSuchRealm(hello.realm, msg);
                    case uris_1.WampUri.Error.ProtoViolation:
                        throw errors_1.Errs.receivedProtocolViolation(hello, msg);
                    default:
                        throw errors_1.Errs.Handshake.unrecognizedError(msg);
                }
            }
            if (!(msg instanceof WM.Welcome)) {
                throw errors_1.Errs.Handshake.unexpectedMessage(msg);
            }
            return msg;
        });
        let sendHello$ = messenger.send$(hello);
        let welcomeMessage$ = rxjs_1.merge(sendHello$, messenger.messages$.pipe(handleAuthentication, handleWelcome, operators_1.take(1)));
        return welcomeMessage$.pipe(operators_1.catchError(err => {
            if (err instanceof route_completion_1.WampusRouteCompletion) {
                throw errors_1.Errs.Handshake.closed();
            }
            throw err;
        }));
    }
    _registerControlRoutes() {
        let catchCompletionError = operators_1.catchError(err => {
            // These routes can be completed without any issue.
            if (err instanceof route_completion_1.WampusRouteCompletion)
                return rxjs_1.EMPTY;
            throw err;
        });
        // Here we detect server-initiated closing of the session.
        let serverInitiatedClose$ = this.protocol.expectAny$([message_type_1.WampType.ABORT], [message_type_1.WampType.GOODBYE]).pipe(operators_1.take(1), operators_1.flatMap((x) => {
            return rxjs_1.concat(this._handleClose$(x));
        }), catchCompletionError);
        // Now we define a few protocol violations that can be committed by the router.
        let serverSentInvalidMessage$ = this.protocol.expectAny$([message_type_1.WampType.WELCOME], [message_type_1.WampType.CHALLENGE]).pipe(operators_1.flatMap(x => {
            return this._abortDueToProtoViolation(`Received unexpected message of type ${message_type_1.WampType[x.type]}.`);
        }), catchCompletionError);
        let serverSentRouterMessage$ = this.protocol.expectAny$([message_type_1.WampType.AUTHENTICATE], [message_type_1.WampType.YIELD], [message_type_1.WampType.HELLO], [message_type_1.WampType.REGISTER], [message_type_1.WampType.CALL], [message_type_1.WampType.PUBLISH], [message_type_1.WampType.UNREGISTER], [message_type_1.WampType.SUBSCRIBE], [message_type_1.WampType.UNSUBSCRIBE], [message_type_1.WampType.CANCEL]).pipe(operators_1.flatMap(x => {
            return this._abortDueToProtoViolation(`Received message of type ${message_type_1.WampType[x.type]}, which is meant for routers not peers.`);
        }), catchCompletionError);
        return rxjs_1.merge(serverSentInvalidMessage$, serverSentRouterMessage$, serverInitiatedClose$);
    }
}
exports.WampusCoreSession = WampusCoreSession;
//# sourceMappingURL=core-session.js.map