"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const message_type_1 = require("../protocol/message.type");
const messages_1 = require("../protocol/messages");
const types_1 = require("./types");
const object_1 = require("../../utils/object");
/**@internal*/
var ErrorLevel;
(function (ErrorLevel) {
    ErrorLevel["Transport"] = "Transport";
    ErrorLevel["Wamp"] = "Wamp";
})(ErrorLevel = exports.ErrorLevel || (exports.ErrorLevel = {}));
function getWampErrorReplyBasedMembers(err) {
    let members = {};
    members._originalWampMessage = err;
    members.error = err.error;
    members.details = err.details;
    if ("args" in err) {
        members.args = err.args;
    }
    if ("kwargs" in err) {
        members.kwargs = err.kwargs;
    }
    object_1.ObjectHelpers.makeEverythingNonEnumerableExcept(members, "kwargs", "args", "details", "error");
    return members;
}
function getWampAbortBasedMembers(abort) {
    let members = {
        _originalWampMessage: abort,
        details: abort.details,
        reason: abort.reason
    };
    object_1.ObjectHelpers.makeNonEnumerable(members, "_originalWampMessage");
    return members;
}
var WM = messages_1.WampMessage;
function getDescriptionByMessage(source) {
    if (source instanceof WM.Authenticate) {
        return "authenticating";
    }
    else if (source instanceof WM.Call) {
        return `calling procedure ${source.procedure}`;
    }
    else if (source instanceof WM.Publish) {
        return `publishing topic ${source.topic}`;
    }
    else if (source instanceof WM.Register) {
        return `registering procedure ${source.procedure}`;
    }
    else if (source instanceof WM.Subscribe) {
        return `subscribing to topic ${source.topic}`;
    }
    else if (source instanceof WM.Unregister) {
        return `unregistering from procedure`;
    }
    else if (source instanceof WM.Unsubscribe) {
        return `unsubscribing from topic`;
    }
    else if (source instanceof WM.Yield) {
        return `yielding response`;
    }
    else if (source instanceof WM.Cancel) {
        return `cancelling invocation`;
    }
    else if (source instanceof WM.Error) {
        return `sending error response`;
    }
    else if (source instanceof WM.Hello) {
        return `beginning handshake`;
    }
    else if (source instanceof WM.Goodbye) {
        return `saying goodbye`;
    }
}
/**@internal*/
var Errs;
(function (Errs) {
    function receivedProtocolViolation(source, error) {
        return new types_1.WampusNetworkError("Received protocol violation during handshake.", getWampAbortBasedMembers(error));
    }
    Errs.receivedProtocolViolation = receivedProtocolViolation;
    function routerDoesNotSupportFeature(source, feature) {
        let operation = getDescriptionByMessage(source);
        return new types_1.WampusIllegalOperationError(`While ${operation}, tried to use the advanced profile feature ${feature}, but it was not supported.`, {});
    }
    Errs.routerDoesNotSupportFeature = routerDoesNotSupportFeature;
    function optionNotAllowed(source, err) {
        let operation = getDescriptionByMessage(source);
        return new types_1.WampusIllegalOperationError(`While ${operation}, one of the options was not allowed.`, getWampErrorReplyBasedMembers(err));
    }
    Errs.optionNotAllowed = optionNotAllowed;
    function sessionIsClosing(source) {
        let operation = getDescriptionByMessage(source);
        let x = new types_1.WampusNetworkError(`While ${operation}, the session was closed.`, {});
        return x;
    }
    Errs.sessionIsClosing = sessionIsClosing;
    let Handshake;
    (function (Handshake) {
        function noAuthenticator(challenge) {
            return new types_1.WampusNetworkError("During handshake, the router sent a CHALLENGE authentication message, but no authenticator was configured.", {
                sourceMsg: challenge
            });
        }
        Handshake.noAuthenticator = noAuthenticator;
        function unexpectedMessage(message) {
            let tp = message_type_1.WampType[message.type];
            let err = new types_1.WampusNetworkError(`During handshake, expected WELCOME, ABORT, or CHALLENGE, but received an invalid message of type ${tp}. `, {
                unexpectedMessage: message
            });
            return err;
        }
        Handshake.unexpectedMessage = unexpectedMessage;
        function unrecognizedError(abort) {
            return new types_1.WampusIllegalOperationError(`During handshake, the router sent an ABORT reply (${abort.reason}).`, getWampAbortBasedMembers(abort));
        }
        Handshake.unrecognizedError = unrecognizedError;
        function closed() {
            return new types_1.WampusNetworkError(`During handshake, the transport abruptly closed.`, {});
        }
        Handshake.closed = closed;
        function noSuchRealm(realm, msg) {
            return new types_1.WampusIllegalOperationError(`Tried to join realm ${realm}, but it did not exist (${msg.reason}).`, getWampAbortBasedMembers(msg));
        }
        Handshake.noSuchRealm = noSuchRealm;
    })(Handshake = Errs.Handshake || (Errs.Handshake = {}));
    let Unregister;
    (function (Unregister) {
        function registrationDoesntExist(procedure, err) {
            return new types_1.WampusIllegalOperationError(`Tried to unregister procedure ${procedure}, but the registration did not exist. This is probably a bug. Going to assume it has been closed.`, getWampErrorReplyBasedMembers(err));
        }
        Unregister.registrationDoesntExist = registrationDoesntExist;
        function other(name, err) {
            return new types_1.WampusIllegalOperationError(`Tried to unregister procedure ${name}, but received an ERROR response (${err.error}).`, getWampErrorReplyBasedMembers(err));
        }
        Unregister.other = other;
    })(Unregister = Errs.Unregister || (Errs.Unregister = {}));
    let Register;
    (function (Register) {
        function procedureAlreadyExists(name, err) {
            return new types_1.WampusIllegalOperationError(`Tried to register procedure ${name}, but a procedure with this name is already registered.`, getWampErrorReplyBasedMembers(err));
        }
        Register.procedureAlreadyExists = procedureAlreadyExists;
        function error(name, err) {
            return new types_1.WampusIllegalOperationError(`Tried to register procedure ${name}, but recieved an ERROR response (${err.error}).`, getWampErrorReplyBasedMembers(err));
        }
        Register.error = error;
        function cannotSendResultTwice(name) {
            return new types_1.WampusIllegalOperationError(`While executing procedure ${name}, tried to yield a response or error, but the final response has already been sent.`, {});
        }
        Register.cannotSendResultTwice = cannotSendResultTwice;
        function doesNotSupportProgressReports(name) {
            return new types_1.WampusIllegalOperationError(`While executing procedure ${name}, tried to send a progress report but this call does not support progress reports.`, {});
        }
        Register.doesNotSupportProgressReports = doesNotSupportProgressReports;
        function resultIncorrectFormat(name, obj) {
            return new types_1.WampusIllegalOperationError(`While executing procedure ${name}, tried to yield an incorrectly structured response.`, {
                result: obj
            });
        }
        Register.resultIncorrectFormat = resultIncorrectFormat;
    })(Register = Errs.Register || (Errs.Register = {}));
    let Subscribe;
    (function (Subscribe) {
        function other(name, err) {
            return new types_1.WampusIllegalOperationError(`Tried to subscribe to ${name}, but received an ERROR response (${err.error}).`, getWampErrorReplyBasedMembers(err));
        }
        Subscribe.other = other;
    })(Subscribe = Errs.Subscribe || (Errs.Subscribe = {}));
    let Unsubscribe;
    (function (Unsubscribe) {
        function subDoesntExist(msg, event) {
            return new types_1.WampusIllegalOperationError(`Tried to unsubscribe from ${event}, but the subscription did not exist. This is probably a bug. Going to assume the subscription is closed.`, getWampErrorReplyBasedMembers(msg));
        }
        Unsubscribe.subDoesntExist = subDoesntExist;
        function other(msg, event) {
            return new types_1.WampusIllegalOperationError(`Tried to unsubscribe from the topic ${event}, but received an ERROR response (${msg.error}).`, getWampErrorReplyBasedMembers(msg));
        }
        Unsubscribe.other = other;
    })(Unsubscribe = Errs.Unsubscribe || (Errs.Unsubscribe = {}));
    let Leave;
    (function (Leave) {
        function networkErrorOnAbort(err) {
            return new types_1.WampusNetworkError("While trying to ABORT, received a network error. Going to terminate connection anyway.", {
                innerError: err
            });
        }
        Leave.networkErrorOnAbort = networkErrorOnAbort;
        function goodbyeTimedOut() {
            return new types_1.WampusNetworkError("While saying GOODBYE, timed out waiting for the router's response.");
        }
        Leave.goodbyeTimedOut = goodbyeTimedOut;
    })(Leave = Errs.Leave || (Errs.Leave = {}));
    let Publish;
    (function (Publish) {
        function unknown(topic, err) {
            return new types_1.WampusIllegalOperationError(`Tried to publish topic ${topic}, but received an error response (${err.error})`, getWampErrorReplyBasedMembers(err));
        }
        Publish.unknown = unknown;
    })(Publish = Errs.Publish || (Errs.Publish = {}));
    let Call;
    (function (Call) {
        function noSuchProcedure(name, err) {
            return new types_1.WampusIllegalOperationError(`Tried to call procedure ${name}, but it did not exist.`, getWampErrorReplyBasedMembers(err));
        }
        Call.noSuchProcedure = noSuchProcedure;
        function noEligibleCallee(name, err) {
            return new types_1.WampusIllegalOperationError(`Tried to call procedure ${name} with exclusions, but no eligible callee was found.`, getWampErrorReplyBasedMembers(err));
        }
        Call.noEligibleCallee = noEligibleCallee;
        function errorResult(name, err) {
            return new types_1.WampusInvocationError(`Called procedure ${name}, the callee replied with an error (${err.error})`, getWampErrorReplyBasedMembers(err));
        }
        Call.errorResult = errorResult;
        function other(name, err) {
            return new types_1.WampusIllegalOperationError(`While calling procedure ${name}, received an error response (${err.error})`, getWampErrorReplyBasedMembers(err));
        }
        Call.other = other;
        function invalidArgument(name, err) {
            return new types_1.WampusIllegalOperationError(`While calling procedure ${name}, one of the arguments was invalid.`, getWampErrorReplyBasedMembers(err));
        }
        Call.invalidArgument = invalidArgument;
        function optionDisallowedDiscloseMe(name, err) {
            return new types_1.WampusIllegalOperationError(`Tried calling procedure ${name} with the disclose_me option, but it was denied.`, getWampErrorReplyBasedMembers(err));
        }
        Call.optionDisallowedDiscloseMe = optionDisallowedDiscloseMe;
        function canceled(name, err) {
            return new types_1.WampusInvocationCanceledError(`While calling the procedure ${name}, the call was cancelled.`, {});
        }
        Call.canceled = canceled;
    })(Call = Errs.Call || (Errs.Call = {}));
    function notAuthorized(source, msg) {
        let operation = getDescriptionByMessage(source);
        return new types_1.WampusIllegalOperationError(`While ${operation}, received a not authorized error.`, getWampErrorReplyBasedMembers(msg));
    }
    Errs.notAuthorized = notAuthorized;
    function invalidUri(source, msg) {
        let operation = getDescriptionByMessage(source);
        return new types_1.WampusIllegalOperationError(`While ${operation}, the URI was invalid.`, getWampErrorReplyBasedMembers(msg));
    }
    Errs.invalidUri = invalidUri;
    function networkFailure(source, msg) {
        let operation = getDescriptionByMessage(source);
        return new types_1.WampusNetworkError(`While ${operation}, received a network failure response`, getWampErrorReplyBasedMembers(msg));
    }
    Errs.networkFailure = networkFailure;
    function sessionClosed(source) {
        let operation = getDescriptionByMessage(source);
        return new types_1.WampusNetworkError(`Tried ${operation}, but the session was already closed.`, {});
    }
    Errs.sessionClosed = sessionClosed;
})(Errs = exports.Errs || (exports.Errs = {}));
//# sourceMappingURL=errors.js.map