"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const static_operators_1 = require("./static-operators");
const operators_1 = require("./operators");
var PromiseStuff;
(function (PromiseStuff) {
    /**
     * Accepts a Promise/A+ constructor and uses it to create a derived promise based on that implementation, with all the additional members.
     * Use this function to wrap an existing Promise implementation without modifying it.
     * Note that promise implementations that define methods beyond  the Promise/A+ interface may return instances of the base promise, instead of the derived one.
     * @param {BasicPromiseConstructor} constructor The promise constructor used to create the derived promise.
     * @returns {ExtendedPromiseConstructor}
     */
    function deriveNew(constructor) {
        class ExtendedPromise extends constructor {
            then(a, b) {
                return super.then(a, b);
            }
            cast() {
                return this;
            }
        }
        Object.setPrototypeOf(ExtendedPromise, constructor);
        for (let k of Object.keys(operators_1.Operators)) {
            let f = operators_1.Operators[k];
            if (!(f.name in ExtendedPromise.prototype)) {
                ExtendedPromise.prototype[f.name] = function (...args) {
                    return f(this, ...args);
                };
            }
        }
        let operators = operators_1.Operators.For(ExtendedPromise);
        for (let k of Object.getOwnPropertyNames(static_operators_1.StaticOperators.prototype)) {
            if (!(k in ExtendedPromise)) {
                ExtendedPromise[k] = function (...args) {
                    return operators[k](...args);
                };
            }
        }
        return ExtendedPromise;
    }
    PromiseStuff.deriveNew = deriveNew;
    /**
     * Accepts an existing Promise/A+ constructor and extends the constructor itself and its prototype with all the available methods.
     * Calling this method on a Promise mutates it.
     * @param {BasicPromiseConstructor} s
     */
    function extendExisting(s) {
        for (let k of Object.keys(operators_1.Operators)) {
            let f = operators_1.Operators[k];
            if (!(f.name in s.prototype)) {
                s.prototype[f.name] = function (...args) {
                    return f(this, ...args);
                };
            }
        }
        s.prototype.cast = function () {
            return this;
        };
        let keySource = static_operators_1.StaticOperators.prototype;
        let impl = operators_1.Operators.For(s);
        for (let k of Object.getOwnPropertyNames(keySource)) {
            if (k === "constructor")
                continue;
            let f = impl[k];
            if (!(f.name in s)) {
                s[f.name] = function (...args) {
                    return impl[f.name](...args);
                };
            }
        }
    }
    PromiseStuff.extendExisting = extendExisting;
})(PromiseStuff = exports.PromiseStuff || (exports.PromiseStuff = {}));
//# sourceMappingURL=core.js.map