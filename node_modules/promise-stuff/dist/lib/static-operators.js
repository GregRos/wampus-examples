"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = require("./common");
class StaticOperators {
    constructor(ctor) {
        this.ctor = ctor;
    }
    /**
     * Static version of the `wait` function.
     * @see [[ExtendedPromiseConstructor.wait]]
     * @param {number | Date} time
     * @param {T} value
     * @returns {P}
     */
    wait(time, value) {
        time = Math.max(0, common_1.normalizeTime(time));
        return new this.ctor((resolve, reject) => {
            setTimeout(() => {
                resolve(value);
            }, time);
        });
    }
    /**
     * Static version of the `soon` function.
     * @see [[ExtendedPromiseConstructor.soon]]
     * @param {(() => T) | (() => PromiseLike<T>)} action
     * @returns {P}
     */
    soon(action) {
        return new this.ctor((resolve, reject) => {
            resolve();
        }).then(() => action());
    }
    /**
     * Static version of the `never` function.
     * @see [[ExtendedPromiseConstructor.soon]]
     * @returns {P}
     */
    never() {
        return new this.ctor((resolve, reject) => {
        });
    }
    /**
     * Static version of the `create` function.
     * @see [[ExtendedPromiseConstructor.create]]
     * @param {(resolve: (value: T) => void, reject: (reason: any) => void) => (void | PromiseLike<void>)} executor
     * @returns {P}
     */
    create(executor) {
        return new this.ctor((resolve, reject) => {
            try {
                let result = executor(resolve, reject);
                if (common_1.isPromiseLike(result)) {
                    result.then(undefined, err => {
                        reject(err);
                    });
                }
            }
            catch (err) {
                reject(err);
            }
        });
    }
    /**
     * Static version of the `from` function.
     * @param {PromiseLike<T>} other
     * @returns {P}
     * @see [[ExtendedPromiseConstructor.from]]
     */
    from(other) {
        return new this.ctor((resolve, reject) => {
            other.then(resolve, reject);
        });
    }
    eventOnce(target, event) {
        return new this.ctor((resolve, reject) => {
            let x = target;
            let onFunc;
            let offFunc;
            if ("on" in x && "off" in x) {
                onFunc = x.on;
                offFunc = x.off;
            }
            else if ("addEventListener" in x && "removeEventListener" in x) {
                onFunc = x.addEventListener;
                offFunc = x.removeEventListener;
            }
            else if ("addListener" in x && "removeListener" in x) {
                onFunc = x.addListener;
                offFunc = x.removeListener;
            }
            else {
                throw new Error("Object does not have event subscription/unsubscription functions.");
            }
            let handler = x => {
                resolve(x);
                offFunc.call(x, event, handler);
            };
            onFunc.call(x, event, handler);
        });
    }
    /**
     * Creates a new instance of the StaticOperators class.
     * @param {BasicPromiseConstructor<P extends BasicPromise<any>>} ctor The promise constructor wrapped by the static operator module.
     * @returns {StaticOperators<BasicPromise<any>>}
     */
    static create(ctor) {
        Math.min();
        return new StaticOperators(ctor);
    }
}
exports.StaticOperators = StaticOperators;
//# sourceMappingURL=static-operators.js.map