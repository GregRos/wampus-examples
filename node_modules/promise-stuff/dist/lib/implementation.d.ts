import { AsyncCallback, BasicPromise, BasicPromiseConstructor, ExtendedPromiseConstructor } from "./definitions";
export declare class StaticOperators<P extends BasicPromise> {
    private ctor;
    constructor(ctor: BasicPromiseConstructor<P>);
    wait<T = any>(time: number | Date, value?: T): P;
    soon<T = any>(action: ((() => T) | (() => PromiseLike<T>))): P;
    never(): P;
    create<T = any>(executor: (resolve: (value: T) => void, reject: (reason: any) => void) => void | PromiseLike<void>): P;
    from<T = any>(other: PromiseLike<T>): P;
    resolve<T = any>(value: T | PromiseLike<T>): P;
    reject(reason: any): P;
    static create<P extends BasicPromise>(ctor: BasicPromiseConstructor<P>): StaticOperators<P>;
}
export declare module Operators {
    function For<P extends BasicPromise>(ctor: BasicPromiseConstructor<P>): StaticOperators<P>;
    function race<P extends BasicPromise, T = any>(promise: P, ...others: PromiseLike<T>[]): P;
    function and<P extends BasicPromise, T = any>(promise: P, ...others: PromiseLike<T>[]): P;
    function fallback<P extends BasicPromise, T = any>(promise: P, ...others: (PromiseLike<T> | T | ((reason: any) => (PromiseLike<T> | T)))[]): P;
    function delay<P extends BasicPromise, T = any>(promise: P, time: number | Date): P;
    function each<P extends BasicPromise, T = any>(promise: P, action: AsyncCallback<any, void>): P;
    function lastly<P extends BasicPromise>(promise: P, action: AsyncCallback<any, void>): P;
    function mustNot<P extends BasicPromise, T = any>(promise: P, failReason: AsyncCallback<T, any>): P;
    function stall<P extends BasicPromise>(promise: P, time: number | Date): P;
    function timeout<P extends BasicPromise, T>(promise: P, time: number | Date, onTimeout?: () => T | PromiseLike<T>): P;
    function test<P extends BasicPromise, T>(promise: P): P;
    function invert<P extends BasicPromise>(promise: P): P;
}
export declare module PromiseStuff {
    /**
     * Accepts a Promise/A+ constructor and uses it to create a derived promise based on that implementation, with all the additional members.
     * Use this function to wrap an existing Promise implementation without modifying it.
     * Note that promise implementations that define methods beyond  the Promise/A+ interface may return instances of the base promise, instead of the derived one.
     * @param {BasicPromiseConstructor} constructor The promise constructor used to create the derived promise.
     * @returns {ExtendedPromiseConstructor}
     */
    function deriveNew(constructor: PromiseConstructorLike): ExtendedPromiseConstructor;
    /**
     * Accepts an existing Promise/A+ constructor and extends the constructor itself and its prototype with all the available methods.
     * Calling this method on a Promise mutates it.
     * @param {BasicPromiseConstructor} s
     */
    function extendExisting(s: PromiseConstructorLike): void;
}
