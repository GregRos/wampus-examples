"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = require("./common");
/** */
let instanceFunctions = [];
let staticFunctions = [];
class StaticOperators {
    constructor(ctor) {
        this.ctor = ctor;
    }
    wait(time, value) {
        time = Math.max(0, common_1.normalizeTime(time));
        return new this.ctor((resolve, reject) => {
            setTimeout(() => {
                resolve(value);
            }, time);
        });
    }
    soon(action) {
        return new this.ctor((resolve, reject) => {
            resolve();
        }).then(() => action());
    }
    never() {
        return new this.ctor((resolve, reject) => {
        });
    }
    create(executor) {
        return new this.ctor((resolve, reject) => {
            try {
                let result = executor(resolve, reject);
                if (common_1.isPromiseLike(result)) {
                    result.then(undefined, err => {
                        reject(err);
                    });
                }
            }
            catch (err) {
                reject(err);
            }
        });
    }
    from(other) {
        return new this.ctor((resolve, reject) => {
            other.then(resolve, reject);
        });
    }
    resolve(value) {
        return common_1.makeResolvingPromise(this.ctor, value);
    }
    reject(reason) {
        return common_1.makeRejectingPromise(this.ctor, reason);
    }
    static create(ctor) {
        return new StaticOperators(ctor);
    }
}
exports.StaticOperators = StaticOperators;
var Operators;
(function (Operators) {
    function For(ctor) {
        return StaticOperators.create(ctor);
    }
    Operators.For = For;
    function race(promise, ...others) {
        let ctor = promise.constructor;
        others.unshift(promise);
        if ("race" in ctor) {
            return ctor.race(others);
        }
        return new ctor((resolve, reject) => {
            let done = false;
            for (let promise of others) {
                promise.then(x => {
                    !done && resolve(x);
                    done = true;
                }, err => {
                    !done && reject(err);
                    done = true;
                });
            }
        });
    }
    Operators.race = race;
    function and(promise, ...others) {
        let ctor = promise.constructor;
        others.unshift(promise);
        if ("all" in ctor) {
            return ctor.all(others);
        }
        return new ctor((resolve, reject) => {
            let arr = [];
            let count = 0;
            let done = false;
            for (let i = 0; i < others.length; i++) {
                let promise = others[i];
                promise.then(x => {
                    if (done)
                        return;
                    arr[i] = x;
                    count++;
                    if (count === others.length) {
                        resolve(arr);
                        done = true;
                    }
                }, err => {
                    reject(err);
                    done = true;
                });
            }
        });
    }
    Operators.and = and;
    function fallback(promise, ...others) {
        let ctor = promise.constructor;
        others.unshift(promise);
        let lastFailure = null;
        return new ctor((resolve, reject) => {
            let resolveOn = i => {
                if (i >= others.length)
                    return reject(lastFailure);
                let current = others[i];
                if (common_1.isFunction(current)) {
                    current = current(lastFailure);
                }
                if (common_1.isPromiseLike(current)) {
                    current.then(x => resolve(x), err => {
                        lastFailure = err;
                        if (i >= others.length - 1) {
                            return reject(err);
                        }
                        else {
                            return resolveOn(i + 1);
                        }
                    });
                }
                else {
                    return resolve(current);
                }
            };
            others.filter(other => common_1.isPromiseLike(other)).forEach(promise => promise.then(undefined, () => { }));
            resolveOn(0);
        });
    }
    Operators.fallback = fallback;
    function delay(promise, time) {
        let ctor = promise.constructor;
        let operators = For(ctor);
        return promise.then(x => operators.wait(time).then(() => x), x => operators.wait(time).then(() => {
            return common_1.makeRejectingPromise(ctor, x);
        }));
    }
    Operators.delay = delay;
    function each(promise, action) {
        return promise.then(x => {
            let p = action(x, true);
            if (p instanceof promise.constructor) {
                return p.then(() => x);
            }
            else {
                return x;
            }
        });
    }
    Operators.each = each;
    function lastly(promise, action) {
        let ctor = promise.constructor;
        return promise.then(x => {
            let p = action(x, true);
            if (p instanceof ctor) {
                return p.then(() => x);
            }
        }, err => {
            let p = action(err, false);
            if (p instanceof ctor) {
                return p.then(() => common_1.makeRejectingPromise(ctor, err));
            }
        });
    }
    Operators.lastly = lastly;
    function mustNot(promise, failReason) {
        let ctor = promise.constructor;
        return promise.then(result => {
            let p = failReason(result, true);
            if (common_1.isPromiseLike(p)) {
                return p.then(err => {
                    if (err) {
                        return common_1.makeRejectingPromise(ctor, err);
                    }
                    else {
                        return result;
                    }
                }, err => common_1.makeRejectingPromise(ctor, err));
            }
            else if (p) {
                return common_1.makeRejectingPromise(ctor, p);
            }
            else {
                return result;
            }
        });
    }
    Operators.mustNot = mustNot;
    function stall(promise, time) {
        let deadline = Date.now() + common_1.normalizeTime(time);
        let ctor = promise.constructor;
        return new ctor((resolve, reject) => {
            promise.then(x => {
                let now = Date.now();
                if (now >= deadline) {
                    resolve(x);
                }
                else {
                    setTimeout(() => {
                        resolve(x);
                    }, now - deadline);
                }
            }, err => {
                let now = Date.now();
                if (now >= deadline) {
                    reject(err);
                }
                else {
                    setTimeout(() => {
                        reject(err);
                    }, now - deadline);
                }
            });
        });
    }
    Operators.stall = stall;
    function timeout(promise, time, onTimeout) {
        let ctor = promise.constructor;
        let stat = For(ctor);
        let timeoutTk = {};
        return race(promise, stat.wait(time, timeoutTk)).then(x => {
            if (x === timeoutTk) {
                let result = onTimeout();
                return result;
            }
            return x;
        });
    }
    Operators.timeout = timeout;
    function test(promise) {
        return promise.then(x => true, x => false);
    }
    Operators.test = test;
    function invert(promise) {
        let ctor = promise.constructor;
        return promise.then(x => common_1.makeRejectingPromise(ctor, x), err => err);
    }
    Operators.invert = invert;
})(Operators = exports.Operators || (exports.Operators = {}));
var PromiseStuff;
(function (PromiseStuff) {
    /**
     * Accepts a Promise/A+ constructor and uses it to create a derived promise based on that implementation, with all the additional members.
     * Use this function to wrap an existing Promise implementation without modifying it.
     * Note that promise implementations that define methods beyond  the Promise/A+ interface may return instances of the base promise, instead of the derived one.
     * @param {BasicPromiseConstructor} constructor The promise constructor used to create the derived promise.
     * @returns {ExtendedPromiseConstructor}
     */
    function deriveNew(constructor) {
        class ExtendedPromise extends constructor {
            then(a, b) {
                return new ExtendedPromise((resolve, reject) => {
                    super.then(a, b).then(resolve, reject);
                });
            }
            cast() {
                return this;
            }
        }
        Object.setPrototypeOf(ExtendedPromise, constructor);
        for (let k of Object.keys(Operators)) {
            let f = Operators[k];
            if (!(f.name in ExtendedPromise.prototype)) {
                ExtendedPromise.prototype[f.name] = function (...args) {
                    return f(this, ...args);
                };
            }
        }
        let operators = Operators.For(constructor);
        for (let k of Object.keys(StaticOperators.prototype)) {
            if (!(k in ExtendedPromise)) {
                ExtendedPromise[k] = function (...args) {
                    return operators[k](...args);
                };
            }
        }
        return ExtendedPromise;
    }
    PromiseStuff.deriveNew = deriveNew;
    /**
     * Accepts an existing Promise/A+ constructor and extends the constructor itself and its prototype with all the available methods.
     * Calling this method on a Promise mutates it.
     * @param {BasicPromiseConstructor} s
     */
    function extendExisting(s) {
        for (let k of Object.keys(Operators)) {
            let f = Operators[k];
            if (!(f.name in s.prototype)) {
                s.prototype[f.name] = function (...args) {
                    return f(this, ...args);
                };
            }
        }
        s.prototype.cast = function () {
            return this;
        };
        let keySource = StaticOperators.prototype;
        let impl = Operators.For(s);
        for (let k of Object.getOwnPropertyNames(keySource)) {
            if (k === "constructor")
                continue;
            let f = impl[k];
            if (!(f.name in s)) {
                s[f.name] = function (...args) {
                    return impl[f.name](...args);
                };
            }
        }
    }
    PromiseStuff.extendExisting = extendExisting;
})(PromiseStuff = exports.PromiseStuff || (exports.PromiseStuff = {}));
//# sourceMappingURL=implementation.js.map